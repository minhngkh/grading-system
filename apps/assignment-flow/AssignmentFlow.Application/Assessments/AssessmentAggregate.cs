using EventFlow.Aggregates;
using EventFlow.Core;
using RubricEngine.Application.Protos;
using static RubricEngine.Application.Protos.RubricProtoService;

namespace AssignmentFlow.Application.Assessments;

public class AssessmentAggregate : AggregateRoot<AssessmentAggregate, AssessmentId>
{
    private readonly ILogger<AssessmentAggregate> logger;
    private readonly RubricProtoServiceClient rubricProtoService;

    public TeacherId TeacherId => State.TeacherId;

    internal readonly AssessmentWriteModel State;

    public AssessmentAggregate(
        AssessmentId id,
        ILogger<AssessmentAggregate> logger,
        RubricProtoServiceClient rubricProtoService)
        : base(id)
    {
        State = new AssessmentWriteModel();
        this.logger = logger;
        this.rubricProtoService = rubricProtoService;

        Register(State);
    }

    public void CreateAssessment(Create.Command command)
    {
        Emit(new Create.AssessmentCreatedEvent
        {
            SubmissionReference = command.SubmissionReference,
            GradingId = command.GradingId,
            TeacherId = command.TeacherId,
            RubricId = command.RubricId
        });
    }

    public void StartAutoGrading()
    {
        Emit(new StartAutoGrading.AutoGradingStartedEvent
        {
            GradingId = State.GradingId
        });
    }

    public void Assess(Assess.Command command)
    {
        if (command.Errors != null && command.Errors.Count != 0)
        {
            Emit(new Assess.AssessmentFailedEvent
            {
                GradingId = State.GradingId,
                Errors = command.Errors
            });
            return;
        }

        if (command.Grader.IsAIGrader)
        {
            NormalizeScores(command.ScoreBreakdowns);
        }

        Emit(new Assess.AssessedEvent
        {
            Grader = command.Grader,
            ScoreBreakdowns = command.ScoreBreakdowns,
            Feedbacks = command.Feedbacks,
            GradingId = State.GradingId,
        });
    }

    public void AssessCriterion(AssessCriterion.Command command)
    {
        Emit(new AssessCriterion.CriterionAssessedEvent
        {
            Grader = command.Grader,
            ScoreBreakdownItem = command.ScoreBreakdownItem,
            Feedbacks = command.Feedbacks,
            Metadata = command.Metadata
        });
    }

    /// <summary>
    /// Since grades generated by the AI grader for each item are in scale 100, we need to apply the criterion weight
    /// defined by the rubric to normalize them to the calculable score for each criterion.
    /// </summary>
    private void NormalizeScores(ScoreBreakdowns scoreBreakdowns)
    {
        var rubric = rubricProtoService.GetRubric(new GetRubricRequest
        {
            RubricId = State.RubricId
        });

        var criteria = rubric.Criteria;
        foreach (var item in scoreBreakdowns)
        {
            var criterion = criteria.FirstOrDefault(c => c.Name == item.CriterionName);

            if (criterion == null)
            {
                logger.LogWarning("Criterion {CriterionName} not found in rubric {RubricId}. Skipping assessment for this criterion.",
                    item.CriterionName, State.RubricId);
                continue;
            }

            item.NormalizeRawScore((decimal)criterion.Weight);
        }
    }

    public void UpdateFeedbacks(UpdateFeedBack.Command command)
    {
        Emit(new UpdateFeedBack.FeedbacksUpdatedEvent
        {
            Feedbacks = command.Feedbacks
        });
    }
}

public class AssessmentId(string id) : Identity<AssessmentId>(id) { }
