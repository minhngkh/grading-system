using EventFlow.Aggregates;
using EventFlow.Core;
using RubricEngine.Application.Protos;
using static RubricEngine.Application.Protos.RubricProtoService;

namespace AssignmentFlow.Application.Assessments;

public class AssessmentAggregate : AggregateRoot<AssessmentAggregate, AssessmentId>
{
    private readonly ILogger<AssessmentAggregate> logger;
    private readonly RubricProtoServiceClient rubricProtoService;

    public TeacherId TeacherId => State.TeacherId;

    internal readonly AssessmentWriteModel State;

    public AssessmentAggregate(
        AssessmentId id,
        ILogger<AssessmentAggregate> logger,
        RubricProtoServiceClient rubricProtoService)
        : base(id)
    {
        State = new AssessmentWriteModel();
        this.logger = logger;
        this.rubricProtoService = rubricProtoService;

        Register(State);
    }

    public void CreateAssessment(Create.Command command)
    {
        var initialScoreBreakdowns = ScoreBreakdowns.New(
            [.. command.Criteria.Select(ScoreBreakdownItem.Pending)]);

        Emit(new Create.AssessmentCreatedEvent
        {
            SubmissionReference = command.SubmissionReference,
            GradingId = command.GradingId,
            TeacherId = command.TeacherId,
            RubricId = command.RubricId,
            InitialScoreBreakdowns = initialScoreBreakdowns
        });
    }

    public void Assess(Assess.Command command)
    {
        if (command.Errors != null && command.Errors.Count != 0)
        {
            Emit(new Assess.AssessmentFailedEvent
            {
                GradingId = State.GradingId,
                Errors = command.Errors
            });
            return;
        }

        if (command.Grader.IsAIGrader)
        {
            NormalizeScores(command.ScoreBreakdowns);
        }

        Emit(new Assess.AssessedEvent
        {
            Grader = command.Grader,
            ScoreBreakdowns = command.ScoreBreakdowns,
            Feedbacks = command.Feedbacks,
            GradingId = State.GradingId,
        });
    }

    public void StartAutoGrading()
    {
        Emit(new AutoGrading.AutoGradingStartedEvent
        {
            GradingId = State.GradingId
        });
    }

    public void Assess(AutoGrading.AssessCriterionCommand command)
    {
        var scoreItem = command.ScoreBreakdownItem;

        if (command.ScoreBreakdownItem.Grader.IsAIGrader && scoreItem.RawScore != 0m)
        {
            var rubric = rubricProtoService.GetRubric(new GetRubricRequest
            {
                RubricId = State.RubricId
            });

            var criteria = rubric.Criteria;
            NormalizeScore(scoreItem, criteria);
        }
        ConditionalEmit(
            command.Feedbacks.Count > 0,
            () => new UpdateFeedBack.FeedbacksUpdatedEvent { Feedbacks = command.Feedbacks });

        Emit(new AutoGrading.CriterionAssessedEvent { ScoreBreakdownItem = scoreItem });
    }

    public void FinishAutoGrading()
    {
        ConditionalEmit(
            AutoGrading.AutoGradingCanBeFinishedSpecification.New().IsSatisfiedBy(State),
            () => new AutoGrading.AutoGradingFinishedEvent { 
                GradingId = State.GradingId,
                Errors = State.ScoreBreakdowns.ToDictionary(
                    item => item.CriterionName.Value,
                    item => item.FailureReason)
            });
    }

    /// <summary>
    /// Since grades generated by the AI grader for each item are in scale 100, we need to apply the criterion weight
    /// defined by the rubric to normalize them to the calculable score for each criterion.
    /// </summary>
    private void NormalizeScores(ScoreBreakdowns scoreBreakdowns)
    {
        var rubric = rubricProtoService.GetRubric(new GetRubricRequest
        {
            RubricId = State.RubricId
        });

        var criteria = rubric.Criteria;
        foreach (var item in scoreBreakdowns)
        {
            NormalizeScore(item, criteria);
        }
    }

    private void NormalizeScore(ScoreBreakdownItem item, IEnumerable<CriterionModel> criteria)
    {
        var criterion = criteria.FirstOrDefault(c => c.Name == item.CriterionName);

        if (criterion == null)
        {
            logger.LogWarning("Criterion {CriterionName} not found in rubric {RubricId}. Skipping assessment for this criterion.",
                item.CriterionName, State.RubricId);
            return;
        }

        item.NormalizeRawScore((decimal)criterion.Weight);
    }

    public void UpdateFeedbacks(UpdateFeedBack.Command command)
    {
        Emit(new UpdateFeedBack.FeedbacksUpdatedEvent
        {
            Feedbacks = command.Feedbacks
        });
    }

    private void ConditionalEmit(bool condition, Func<AggregateEvent<AssessmentAggregate, AssessmentId>> eventPredicate)
    {
        if (condition)
        {
            Emit(eventPredicate());
        }
    }
}

public class AssessmentId(string id) : Identity<AssessmentId>(id) { }
