 
/**
 * This file was automatically generated by json-schema-to-typescript.
 * DO NOT MODIFY IT BY HAND. Instead, modify the source JSONSchema file,
 * and run json-schema-to-typescript to regenerate this file.
 */

export type Version = string;
export type RuleId = string;
export type Fpath = string;
export type RawJson = unknown;
export type MatchSeverity =
  | "ERROR"
  | "WARNING"
  | "EXPERIMENT"
  | "INVENTORY"
  | "CRITICAL"
  | "HIGH"
  | "MEDIUM"
  | "LOW"
  | "INFO";
export type Ecosystem =
  | "npm"
  | "pypi"
  | "gem"
  | "gomod"
  | "cargo"
  | "maven"
  | "composer"
  | "nuget"
  | "pub"
  | "swiftpm"
  | "cocoapods"
  | "mix"
  | "hex"
  | "opam";
export type DependencyKind = "direct" | "transitive" | "unknown";
export type ScaMatchKind = never[] | "DirectReachable";
export type ValidationState = "CONFIRMED_VALID" | "CONFIRMED_INVALID" | "VALIDATION_ERROR" | "NO_VALIDATOR";
export type Sha1 = string;
export type Datetime = string;
export type MatchCallTrace = never[];
export type EngineOfFinding = "OSS" | "PRO" | never[];
export type ErrorSeverity = "error" | "warn" | "info";
export type ErrorType =
  | "Lexical error"
  | "Syntax error"
  | "Other syntax error"
  | "AST builder error"
  | "Rule parse error"
  | "SemgrepWarning"
  | "SemgrepError"
  | "InvalidRuleSchemaError"
  | "UnknownLanguageError"
  | "Invalid YAML"
  | "Internal matching error"
  | "Semgrep match found"
  | "Too many matches"
  | "Fatal error"
  | "Timeout"
  | "Out of memory"
  | "Stack overflow"
  | "Timeout during interfile analysis"
  | "OOM during interfile analysis"
  | "Missing plugin"
  | never[]
  | "Pattern parse error"
  | "Incompatible rule";
export type SkipReason =
  | "always_skipped"
  | "semgrepignore_patterns_match"
  | "cli_include_flags_do_not_match"
  | "cli_exclude_flags_match"
  | "exceeded_size_limit"
  | "analysis_failed_parser_or_internal_error"
  | "excluded_by_config"
  | "wrong_language"
  | "too_big"
  | "minified"
  | "binary"
  | "irrelevant_rule"
  | "too_many_matches"
  | "Gitignore_patterns_match"
  | "Dotfile"
  | "Nonexistent_file"
  | "insufficient_permissions";
export type MatchingOperation =
  | "And"
  | "Or"
  | "Inside"
  | "Anywhere"
  | never[]
  | "Negation"
  | "Taint"
  | "TaintSource"
  | "TaintSink"
  | "TaintSanitizer"
  | "EllipsisAndStmts"
  | "ClassHeaderAndElems";
/**
 * @minItems 2
 */
export type RuleIdAndEngineKind = never[];
export type EngineKind = "OSS" | "PRO";
export type UnresolvedReason = "failed" | "skipped" | "unsupported" | "disabled";
export type ResolutionMethod = "LockfileParsing" | "DynamicResolution";

/**
 * Translated by atdcat from 'semgrep_output_v1.atd'.
 */
export interface CliOutput {
  version?: Version;
  results: CliMatch[];
  errors: CliError[];
  paths: ScannedAndSkipped;
  time?: Profile;
  explanations?: MatchingExplanation[];
  rules_by_engine?: RuleIdAndEngineKind[];
  engine_requested?: EngineKind;
  interfile_languages_used?: string[];
  skipped_rules?: SkippedRule[];
  subprojects?: CliOutputSubprojectInfo[];
  [k: string]: unknown;
}
export interface CliMatch {
  check_id: RuleId;
  path: Fpath;
  start: Position;
  end: Position;
  extra: CliMatchExtra;
  [k: string]: unknown;
}
export interface Position {
  line: number;
  col: number;
  offset?: number;
  [k: string]: unknown;
}
export interface CliMatchExtra {
  metavars?: Metavars;
  message: string;
  fix?: string;
  fixed_lines?: string[];
  metadata: RawJson;
  severity: MatchSeverity;
  fingerprint: string;
  lines: string;
  is_ignored?: boolean;
  sca_info?: ScaMatch;
  validation_state?: ValidationState;
  historical_info?: HistoricalInfo;
  dataflow_trace?: MatchDataflowTrace;
  engine_kind?: EngineOfFinding;
  extra_extra?: RawJson;
  [k: string]: unknown;
}
export interface Metavars {
  [k: string]: MetavarValue;
}
export interface MetavarValue {
  start: Position;
  end: Position;
  abstract_content: string;
  propagated_value?: SvalueValue;
  [k: string]: unknown;
}
export interface SvalueValue {
  svalue_start?: Position;
  svalue_end?: Position;
  svalue_abstract_content: string;
  [k: string]: unknown;
}
export interface ScaMatch {
  reachability_rule: boolean;
  sca_finding_schema: number;
  dependency_match: DependencyMatch;
  reachable: boolean;
  kind?: ScaMatchKind;
  [k: string]: unknown;
}
export interface DependencyMatch {
  dependency_pattern: ScaPattern;
  found_dependency: FoundDependency;
  lockfile: Fpath;
  [k: string]: unknown;
}
export interface ScaPattern {
  ecosystem: Ecosystem;
  package: string;
  semver_range: string;
  [k: string]: unknown;
}
export interface FoundDependency {
  package: string;
  version: string;
  ecosystem: Ecosystem;
  allowed_hashes: {
    [k: string]: string[];
  };
  resolved_url?: string;
  transitivity: DependencyKind;
  manifest_path?: Fpath;
  lockfile_path?: Fpath;
  line_number?: number;
  children?: DependencyChild[];
  git_ref?: string;
  [k: string]: unknown;
}
export interface DependencyChild {
  package: string;
  version: string;
  [k: string]: unknown;
}
export interface HistoricalInfo {
  git_commit: Sha1;
  git_blob?: Sha1;
  git_commit_timestamp: Datetime;
  [k: string]: unknown;
}
export interface MatchDataflowTrace {
  taint_source?: MatchCallTrace;
  intermediate_vars?: MatchIntermediateVar[];
  taint_sink?: MatchCallTrace;
  [k: string]: unknown;
}
export interface MatchIntermediateVar {
  location: Location;
  content: string;
  [k: string]: unknown;
}
export interface Location {
  path: Fpath;
  start: Position;
  end: Position;
  [k: string]: unknown;
}
export interface CliError {
  code: number;
  level: ErrorSeverity;
  type: ErrorType;
  rule_id?: RuleId;
  message?: string;
  path?: Fpath;
  long_msg?: string;
  short_msg?: string;
  spans?: ErrorSpan[];
  help?: string;
  [k: string]: unknown;
}
export interface ErrorSpan {
  file: Fpath;
  start: Position;
  end: Position;
  source_hash?: string;
  config_start?: Position;
  config_end?: Position;
  config_path?: string[] | null;
  context_start?: Position;
  context_end?: Position;
  [k: string]: unknown;
}
export interface ScannedAndSkipped {
  scanned: Fpath[];
  skipped?: SkippedTarget[];
  [k: string]: unknown;
}
export interface SkippedTarget {
  path: Fpath;
  reason: SkipReason;
  details?: string;
  rule_id?: RuleId;
  [k: string]: unknown;
}
export interface Profile {
  rules: RuleId[];
  rules_parse_time: number;
  profiling_times: {
    [k: string]: number;
  };
  parsing_time?: ParsingTime;
  targets: TargetTimes[];
  total_bytes: number;
  max_memory_bytes?: number;
  [k: string]: unknown;
}
export interface ParsingTime {
  total_time: number;
  per_file_time: SummaryStats;
  very_slow_files: FileTime[];
  [k: string]: unknown;
}
export interface SummaryStats {
  mean: number;
  std_dev: number;
  [k: string]: unknown;
}
export interface FileTime {
  fpath: Fpath;
  ftime: number;
  [k: string]: unknown;
}
export interface TargetTimes {
  path: Fpath;
  num_bytes: number;
  match_times: number[];
  parse_times: number[];
  run_time: number;
  [k: string]: unknown;
}
export interface MatchingExplanation {
  op: MatchingOperation;
  children: MatchingExplanation[];
  matches: CoreMatch[];
  loc: Location;
  extra?: MatchingExplanationExtra;
  [k: string]: unknown;
}
export interface CoreMatch {
  check_id: RuleId;
  path: Fpath;
  start: Position;
  end: Position;
  extra: CoreMatchExtra;
  [k: string]: unknown;
}
export interface CoreMatchExtra {
  metavars: Metavars;
  engine_kind: EngineOfFinding;
  is_ignored: boolean;
  message?: string;
  metadata?: RawJson;
  severity?: MatchSeverity;
  fix?: string;
  dataflow_trace?: MatchDataflowTrace;
  sca_match?: ScaMatch;
  validation_state?: ValidationState;
  historical_info?: HistoricalInfo;
  extra_extra?: RawJson;
  [k: string]: unknown;
}
export interface MatchingExplanationExtra {
  before_negation_matches: never[] | "None";
  before_filter_matches: never[] | "None";
  [k: string]: unknown;
}
export interface SkippedRule {
  rule_id: RuleId;
  details: string;
  position: Position;
  [k: string]: unknown;
}
export interface CliOutputSubprojectInfo {
  dependency_sources: Fpath[];
  resolved: boolean;
  unresolved_reason?: UnresolvedReason;
  resolved_stats?: DependencyResolutionStats;
  [k: string]: unknown;
}
export interface DependencyResolutionStats {
  resolution_method: ResolutionMethod;
  dependency_count: number;
  ecosystem: Ecosystem;
  [k: string]: unknown;
}
